/**
 * Benchmark.jack
 * A heavy class designed to stress test the Parser's speed and robustness.
 * It simulates a complex matrix operation library with a physics stress test.
 */
class Benchmark {

    // 1. Heavy Field/Static Declarations
    field int x, y, z;
    field Array grid;
    field Benchmark parent;
    field boolean isActive, isVisible, isCached;

    static int instanceCount;
    static Array cacheTable;
    static boolean GLOBAL_DEBUG;

    /** Constructor with complex initialisation */
    constructor Benchmark new(int ax, int ay, int az) {
        var int i;

        let x = ax;
        let y = ay;
        let z = az;
        let instanceCount = instanceCount + 1;
        let isActive = true;
        let grid = Array.new(100);

        // Nested Loop Initialization
        let i = 0;
        while (i < 100) {
            let grid[i] = (i * x) + (y / 2);
            if ((i > 50) & (z < 10)) {
                let grid[i] = grid[i] - 1;
            } else {
                let grid[i] = grid[i] + 1;
            }
            let i = i + 1;
        }
        return this;
    }

    /** A method designed to create deep Parse Trees for expressions */
    method void calculatePhysics(int delta, int gravity) {
        var int velocity, acceleration, friction;
        var boolean collision;
        var Array temp;

        let friction = 2;

        // Deep Expression Tree
        let velocity = ((x * delta) + (y / gravity)) - ((z * friction) + (delta / 2));

        // Deeply Nested Control Flow
        if (isActive) {
            if (velocity > 100) {
                let x = x + velocity;
                if (x > 1000) {
                    let x = 1000;
                    let collision = true;
                } else {
                    let collision = false;
                }
            } else {
                if (velocity < -100) {
                    let x = x - velocity; // Double negative logic
                }
            }
        }

        // Complex Array Access + Method Call chain
        if (collision) {
            do grid.dispose();
            let grid = Array.new(50);
            let grid[0] = x;
            let grid[1] = y;
            do computeHash(grid[0], grid[1], velocity);
        }
        return;
    }

    /** A function with many local variables and boolean logic */
    function int computeHash(int a, int b, int c) {
        var int h1, h2, h3, result;
        var boolean flag1, flag2;

        let flag1 = (a > b) & (b > c);
        let flag2 = (a = c) | (b = 0);

        if (flag1) {
            let h1 = a * 31;
        } else {
            let h1 = b * 17;
        }

        if (~flag2) {
            let h2 = c * 13;
        } else {
            let h2 = 1;
        }

        // The "Torture" Expression
        let result = (h1 + h2) - ((a * b) / (c + 1)) + (h1 * (h2 - 5));

        return result;
    }

    /** Method to test "void" return and object interactions */
    method void setParent(Benchmark p) {
        let parent = p;
        if (~(parent = null)) {
            do parent.calculatePhysics(10, 9);
        }
        return;
    }

    /** Main entry point simulating a game loop */
    function void main() {
        var Benchmark b1, b2;
        var int i, limit;

        let limit = 1000;
        let b1 = Benchmark.new(10, 20, 30);
        let b2 = Benchmark.new(5, 5, 5);

        do b2.setParent(b1);

        let i = 0;
        while (i < limit) {
            do b1.calculatePhysics(i, 9);
            do b2.calculatePhysics(i + 1, 9);

            if ((i / 100) = 5) {
                do Output.printString("Halfway done...");
                do Output.println();
            }

            let i = i + 1;
        }

        do b1.dispose(); // Assuming dispose exists (standard pattern)
        do b2.dispose();
        return;
    }

    method void dispose() {
        do grid.dispose();
        do Memory.deAlloc(this);
        return;
    }
}